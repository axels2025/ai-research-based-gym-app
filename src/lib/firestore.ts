import { 
  collection, 
  doc, 
  getDoc, 
  setDoc, 
  updateDoc, 
  deleteDoc, 
  query, 
  where, 
  orderBy, 
  getDocs,
  addDoc,
  Timestamp
} from 'firebase/firestore';
import { db } from './firebase';

// Types
export interface WorkoutProgram {
  id: string;
  userId: string;
  name: string;
  currentWeek: number;
  totalWeeks: number;
  workoutsCompleted: number;
  totalWorkouts: number;
  // 2-week rotation system
  currentRotation: number; // Current 2-week block (1, 2, 3)
  totalRotations: number; // Total 2-week blocks (usually 3 for 6-week program)
  rotationStartDate?: Timestamp; // When current rotation started
  rotationCompletedWeeks: number; // Weeks completed in current rotation (0, 1, or 2)
  // Program history and regeneration
  isActive: boolean; // Whether this is the active program
  previousProgramId?: string; // Reference to previous program for rollback
  regenerationCount: number; // How many times program has been regenerated
  aiGenerated: boolean; // Whether generated by AI or default
  generationSource: 'ai' | 'default' | 'regenerated';
  createdAt: Timestamp;
  updatedAt: Timestamp;
}

export interface Workout {
  id: string;
  userId: string;
  programId: string;
  title: string;
  week: number;
  day: number;
  exercises: number;
  estimatedTime: number;
  isCompleted: boolean;
  completedAt?: Timestamp;
  // 2-week rotation support
  rotation: number; // Which 2-week block this workout belongs to
  rotationWeek: number; // Week within the rotation (1 or 2)
  exerciseVariations?: string[]; // Alternative exercises for variety
  progressionNotes?: string; // How this workout progresses from previous rotation
  createdAt: Timestamp;
  updatedAt: Timestamp;
}

export interface Exercise {
  id: string;
  workoutId: string;
  name: string;
  sets: number;
  reps: string;
  weight?: number;
  restTime: number;
  notes?: string;
  isCompleted: boolean;
  completedAt?: Timestamp;
  // Enhanced exercise data
  targetMuscles?: string[];
  difficulty?: 'beginner' | 'intermediate' | 'advanced';
  progressionNotes?: string;
  alternatives?: string[]; // Alternative exercises
  // Performance tracking
  previousWeight?: number;
  progressionSuggestion?: {
    type: 'weight' | 'reps' | 'sets';
    suggestion: number;
    reason: string;
  };
}

export interface WorkoutSession {
  id: string;
  userId: string;
  workoutId: string;
  startedAt: Timestamp;
  completedAt?: Timestamp;
  exercises: Exercise[];
  duration?: number;
  notes?: string;
}

// Workout Programs
export async function createWorkoutProgram(userId: string, programData: Omit<WorkoutProgram, 'id' | 'userId' | 'createdAt' | 'updatedAt'>) {
  const programRef = doc(collection(db, 'programs'));
  const program: WorkoutProgram = {
    id: programRef.id,
    userId,
    currentRotation: 1,
    totalRotations: 4,
    rotationCompletedWeeks: 0,
    isActive: true,
    regenerationCount: 0,
    aiGenerated: false,
    generationSource: 'default',
    ...programData,
    createdAt: Timestamp.now(),
    updatedAt: Timestamp.now(),
  };
  
  await setDoc(programRef, program);
  return program;
}

export async function getUserPrograms(userId: string): Promise<WorkoutProgram[]> {
  const q = query(
    collection(db, 'programs'),
    where('userId', '==', userId),
    orderBy('createdAt', 'desc')
  );
  
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(doc => doc.data() as WorkoutProgram);
}

export async function updateWorkoutProgram(programId: string, updates: Partial<WorkoutProgram>) {
  const programRef = doc(db, 'programs', programId);
  await updateDoc(programRef, {
    ...updates,
    updatedAt: Timestamp.now(),
  });
}

// Workouts
export async function createWorkout(userId: string, workoutData: Omit<Workout, 'id' | 'userId' | 'createdAt' | 'updatedAt'>) {
  const workoutRef = doc(collection(db, 'workouts'));
  const workout: Workout = {
    id: workoutRef.id,
    userId,
    rotation: Math.ceil(workoutData.week / 2), // Calculate which 2-week block
    rotationWeek: workoutData.week % 2 === 0 ? 2 : 1, // Week within rotation
    ...workoutData,
    createdAt: Timestamp.now(),
    updatedAt: Timestamp.now(),
  };
  
  await setDoc(workoutRef, workout);
  return workout;
}

export async function getUserWorkouts(userId: string, programId?: string): Promise<Workout[]> {
  let q = query(
    collection(db, 'workouts'),
    where('userId', '==', userId),
    orderBy('week', 'asc'),
    orderBy('day', 'asc')
  );
  
  if (programId) {
    q = query(
      collection(db, 'workouts'),
      where('userId', '==', userId),
      where('programId', '==', programId),
      orderBy('week', 'asc'),
      orderBy('day', 'asc')
    );
  }
  
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(doc => doc.data() as Workout);
}

export async function getWorkoutById(workoutId: string): Promise<Workout | null> {
  const workoutRef = doc(db, 'workouts', workoutId);
  const workoutDoc = await getDoc(workoutRef);
  
  if (workoutDoc.exists()) {
    return workoutDoc.data() as Workout;
  }
  
  return null;
}

export async function updateWorkout(workoutId: string, updates: Partial<Workout>) {
  const workoutRef = doc(db, 'workouts', workoutId);
  await updateDoc(workoutRef, {
    ...updates,
    updatedAt: Timestamp.now(),
  });
}

export async function completeWorkout(workoutId: string) {
  await updateWorkout(workoutId, {
    isCompleted: true,
    completedAt: Timestamp.now(),
  });
}

// Workout Sessions
export async function createWorkoutSession(userId: string, sessionData: Omit<WorkoutSession, 'id' | 'userId'>) {
  const sessionRef = doc(collection(db, 'workoutSessions'));
  const session: WorkoutSession = {
    id: sessionRef.id,
    userId,
    ...sessionData,
  };
  
  await setDoc(sessionRef, session);
  return session;
}

export async function updateWorkoutSession(sessionId: string, updates: Partial<WorkoutSession>) {
  const sessionRef = doc(db, 'workoutSessions', sessionId);
  await updateDoc(sessionRef, updates);
}

export async function getUserWorkoutSessions(userId: string): Promise<WorkoutSession[]> {
  const q = query(
    collection(db, 'workoutSessions'),
    where('userId', '==', userId),
    orderBy('startedAt', 'desc')
  );
  
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(doc => doc.data() as WorkoutSession);
}

// Initialize default program for new users
export async function initializeDefaultProgram(userId: string) {
  // Create default program
  const program = await createWorkoutProgram(userId, {
    name: "Strength & Hypertrophy Program",
    currentWeek: 1,
    totalWeeks: 8,
    workoutsCompleted: 0,
    totalWorkouts: 24,
  });

  // Create default workouts
  const defaultWorkouts = [
    {
      programId: program.id,
      title: "Push Day - Upper Body",
      week: 1,
      day: 1,
      exercises: 6,
      estimatedTime: 75,
      isCompleted: false,
    },
    {
      programId: program.id,
      title: "Pull Day - Back & Biceps",
      week: 1,
      day: 2,
      exercises: 5,
      estimatedTime: 65,
      isCompleted: false,
    },
    {
      programId: program.id,
      title: "Legs & Core",
      week: 1,
      day: 3,
      exercises: 7,
      estimatedTime: 85,
      isCompleted: false,
    },
  ];

  const workouts = await Promise.all(
    defaultWorkouts.map(workout => createWorkout(userId, workout))
  );

  return { program, workouts };
}

// Program Regeneration Functions
export async function archiveCurrentProgram(userId: string, currentProgramId: string) {
  const programRef = doc(db, 'programs', currentProgramId);
  await updateDoc(programRef, {
    isActive: false,
    updatedAt: Timestamp.now(),
  });
}

export async function getActiveProgram(userId: string): Promise<WorkoutProgram | null> {
  const q = query(
    collection(db, 'programs'),
    where('userId', '==', userId),
    where('isActive', '==', true),
    orderBy('createdAt', 'desc')
  );
  
  const querySnapshot = await getDocs(q);
  const programs = querySnapshot.docs.map(doc => doc.data() as WorkoutProgram);
  return programs.length > 0 ? programs[0] : null;
}

export async function canRegenerateProgram(userId: string): Promise<{
  canRegenerate: boolean;
  reason?: string;
  suggestedWaitDays?: number;
}> {
  const activeProgram = await getActiveProgram(userId);
  
  if (!activeProgram) {
    return { canRegenerate: true };
  }
  
  const programAge = Date.now() - activeProgram.createdAt.seconds * 1000;
  const daysSinceCreation = Math.floor(programAge / (1000 * 60 * 60 * 24));
  
  // Don't allow regeneration if program is less than 7 days old
  if (daysSinceCreation < 7) {
    return {
      canRegenerate: false,
      reason: 'Program is too new. Give it at least a week to see progress.',
      suggestedWaitDays: 7 - daysSinceCreation,
    };
  }
  
  // Encourage regeneration after 4-6 weeks
  if (daysSinceCreation >= 28) {
    return {
      canRegenerate: true,
      reason: 'Perfect timing! Your body is ready for a new challenge.',
    };
  }
  
  // Check if user has made good progress
  const progressPercentage = (activeProgram.workoutsCompleted / activeProgram.totalWorkouts) * 100;
  if (progressPercentage < 50) {
    return {
      canRegenerate: false,
      reason: 'Consider completing more of your current program first.',
    };
  }
  
  return { canRegenerate: true };
}

export async function regenerateWorkoutProgram(
  userId: string, 
  newProgramData: Omit<WorkoutProgram, 'id' | 'userId' | 'createdAt' | 'updatedAt' | 'currentRotation' | 'totalRotations' | 'rotationCompletedWeeks' | 'isActive' | 'regenerationCount' | 'aiGenerated' | 'generationSource'>
): Promise<WorkoutProgram> {
  // Archive current program
  const currentProgram = await getActiveProgram(userId);
  if (currentProgram) {
    await archiveCurrentProgram(userId, currentProgram.id);
  }
  
  // Create new program
  const newProgram = await createWorkoutProgram(userId, {
    ...newProgramData,
    previousProgramId: currentProgram?.id,
    regenerationCount: (currentProgram?.regenerationCount || 0) + 1,
    aiGenerated: true,
    generationSource: 'regenerated',
    rotationStartDate: Timestamp.now(),
  });
  
  return newProgram;
}

export async function revertToPreviousProgram(userId: string): Promise<WorkoutProgram | null> {
  const currentProgram = await getActiveProgram(userId);
  if (!currentProgram?.previousProgramId) {
    return null;
  }
  
  // Check if revert is still possible (within 24 hours)
  const timeSinceGeneration = Date.now() - currentProgram.createdAt.seconds * 1000;
  const hoursElapsed = timeSinceGeneration / (1000 * 60 * 60);
  
  if (hoursElapsed > 24) {
    throw new Error('Revert period has expired (24 hours)');
  }
  
  // Deactivate current program
  await archiveCurrentProgram(userId, currentProgram.id);
  
  // Reactivate previous program
  const previousProgramRef = doc(db, 'programs', currentProgram.previousProgramId);
  await updateDoc(previousProgramRef, {
    isActive: true,
    updatedAt: Timestamp.now(),
  });
  
  // Get the reactivated program
  const previousProgram = await getDoc(previousProgramRef);
  return previousProgram.exists() ? previousProgram.data() as WorkoutProgram : null;
}

// 2-Week Rotation Functions
export async function advanceRotation(userId: string, programId: string): Promise<void> {
  const programRef = doc(db, 'programs', programId);
  const program = await getDoc(programRef);
  
  if (!program.exists()) {
    throw new Error('Program not found');
  }
  
  const programData = program.data() as WorkoutProgram;
  const nextRotation = Math.min(programData.currentRotation + 1, programData.totalRotations);
  
  await updateDoc(programRef, {
    currentRotation: nextRotation,
    rotationCompletedWeeks: 0,
    rotationStartDate: Timestamp.now(),
    updatedAt: Timestamp.now(),
  });
}

export async function updateRotationProgress(userId: string, programId: string, weeksCompleted: number): Promise<void> {
  const programRef = doc(db, 'programs', programId);
  await updateDoc(programRef, {
    rotationCompletedWeeks: weeksCompleted,
    updatedAt: Timestamp.now(),
  });
  
  // Auto-advance if rotation is complete
  if (weeksCompleted >= 2) {
    await advanceRotation(userId, programId);
  }
}

export async function getRotationStatus(programId: string): Promise<{
  currentRotation: number;
  totalRotations: number;
  weeksInCurrentRotation: number;
  daysUntilNextRotation?: number;
  rotationProgress: number; // 0-100%
}> {
  const programRef = doc(db, 'programs', programId);
  const program = await getDoc(programRef);
  
  if (!program.exists()) {
    throw new Error('Program not found');
  }
  
  const programData = program.data() as WorkoutProgram;
  const rotationProgress = (programData.rotationCompletedWeeks / 2) * 100;
  
  let daysUntilNextRotation: number | undefined;
  if (programData.rotationStartDate) {
    const daysSinceStart = Math.floor((Date.now() - programData.rotationStartDate.seconds * 1000) / (1000 * 60 * 60 * 24));
    daysUntilNextRotation = Math.max(0, 14 - daysSinceStart);
  }
  
  return {
    currentRotation: programData.currentRotation,
    totalRotations: programData.totalRotations,
    weeksInCurrentRotation: programData.rotationCompletedWeeks,
    daysUntilNextRotation,
    rotationProgress,
  };
}